// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"march-inventory/cmd/app/graph/types"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Auth func(ctx context.Context, obj interface{}, next graphql.Resolver, scopes []*string) (res interface{}, err error)
}

type ComplexityRoot struct {
	DeleteInventoryBranchResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	DeleteInventoryBrandResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	DeleteInventoryResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	DeleteInventoryTypeResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	DeletedInventory struct {
		Branch    func(childComplexity int) int
		Brand     func(childComplexity int) int
		Inventory func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	DeletedInventoryResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	DeletedInventoryType struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UpdatedBy func(childComplexity int) int
	}

	InventoriesResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	Inventory struct {
		Amount          func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		Description     func(childComplexity int) int
		ExpiryDate      func(childComplexity int) int
		Favorite        func(childComplexity int) int
		ID              func(childComplexity int) int
		InventoryBranch func(childComplexity int) int
		InventoryBrand  func(childComplexity int) int
		InventoryType   func(childComplexity int) int
		InventoryTypeID func(childComplexity int) int
		Name            func(childComplexity int) int
		Price           func(childComplexity int) int
		PriceMember     func(childComplexity int) int
		ReorderLevel    func(childComplexity int) int
		SerialNumber    func(childComplexity int) int
		Size            func(childComplexity int) int
		Sku             func(childComplexity int) int
		Sold            func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
	}

	InventoryBranch struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
	}

	InventoryBranchsDataResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	InventoryBrand struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
	}

	InventoryBrandsDataResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	InventoryDataResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	InventoryName struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	InventoryNameResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	InventoryType struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
	}

	InventoryTypeResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	InventoryTypesResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	Mutation struct {
		DeleteInventory       func(childComplexity int, id string) int
		DeleteInventoryBranch func(childComplexity int, id string) int
		DeleteInventoryBrand  func(childComplexity int, id string) int
		DeleteInventoryType   func(childComplexity int, id string) int
		FavoriteInventory     func(childComplexity int, id string) int
		RecoveryHardDeleted   func(childComplexity int, input types.RecoveryHardDeletedInput) int
		UploadInventory       func(childComplexity int, input types.UploadInventoryInput) int
		UpsertInventory       func(childComplexity int, input types.UpsertInventoryInput) int
		UpsertInventoryBranch func(childComplexity int, input types.UpsertInventoryBranchInput) int
		UpsertInventoryBrand  func(childComplexity int, input types.UpsertInventoryBrandInput) int
		UpsertInventoryType   func(childComplexity int, input types.UpsertInventoryTypeInput) int
	}

	MutationInventoryBranchResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	MutationInventoryBrandResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	MutationInventoryResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	MutationInventoryTypeResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	Query struct {
		GetInventories         func(childComplexity int, params *types.ParamsInventory) int
		GetInventory           func(childComplexity int, id *string) int
		GetInventoryAllDeleted func(childComplexity int) int
		GetInventoryBranchs    func(childComplexity int, params *types.ParamsInventoryBranch) int
		GetInventoryBrand      func(childComplexity int, id *string) int
		GetInventoryBrands     func(childComplexity int, params *types.ParamsInventoryBrand) int
		GetInventoryNames      func(childComplexity int) int
		GetInventoryType       func(childComplexity int, id *string) int
		GetInventoryTypes      func(childComplexity int, params *types.ParamsInventoryType) int
	}

	RecoveryHardDeleted struct {
		ID   func(childComplexity int) int
		Mode func(childComplexity int) int
		Type func(childComplexity int) int
	}

	RecoveryHardDeletedResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}

	ResponseId struct {
		ID func(childComplexity int) int
	}

	ResponseInventories struct {
		Inventories func(childComplexity int) int
		PageLimit   func(childComplexity int) int
		PageNo      func(childComplexity int) int
		TotalPage   func(childComplexity int) int
		TotalRow    func(childComplexity int) int
	}

	Status struct {
		Code    func(childComplexity int) int
		Message func(childComplexity int) int
	}

	UploadInventory struct {
		ID      func(childComplexity int) int
		Reason  func(childComplexity int) int
		Success func(childComplexity int) int
	}

	UploadInventoryResponse struct {
		Data   func(childComplexity int) int
		Status func(childComplexity int) int
	}
}

type MutationResolver interface {
	UpsertInventoryBrand(ctx context.Context, input types.UpsertInventoryBrandInput) (*types.MutationInventoryBrandResponse, error)
	DeleteInventoryBrand(ctx context.Context, id string) (*types.MutationInventoryBrandResponse, error)
	UploadInventory(ctx context.Context, input types.UploadInventoryInput) (*types.UploadInventoryResponse, error)
	UpsertInventory(ctx context.Context, input types.UpsertInventoryInput) (*types.MutationInventoryResponse, error)
	DeleteInventory(ctx context.Context, id string) (*types.MutationInventoryResponse, error)
	FavoriteInventory(ctx context.Context, id string) (*types.MutationInventoryResponse, error)
	RecoveryHardDeleted(ctx context.Context, input types.RecoveryHardDeletedInput) (*types.RecoveryHardDeletedResponse, error)
	UpsertInventoryBranch(ctx context.Context, input types.UpsertInventoryBranchInput) (*types.MutationInventoryBranchResponse, error)
	DeleteInventoryBranch(ctx context.Context, id string) (*types.MutationInventoryBranchResponse, error)
	UpsertInventoryType(ctx context.Context, input types.UpsertInventoryTypeInput) (*types.MutationInventoryResponse, error)
	DeleteInventoryType(ctx context.Context, id string) (*types.MutationInventoryResponse, error)
}
type QueryResolver interface {
	GetInventoryBrand(ctx context.Context, id *string) (*types.InventoryBrand, error)
	GetInventoryBrands(ctx context.Context, params *types.ParamsInventoryBrand) (*types.InventoryBrandsDataResponse, error)
	GetInventoryNames(ctx context.Context) (*types.InventoryNameResponse, error)
	GetInventory(ctx context.Context, id *string) (*types.InventoryDataResponse, error)
	GetInventories(ctx context.Context, params *types.ParamsInventory) (*types.InventoriesResponse, error)
	GetInventoryAllDeleted(ctx context.Context) (*types.DeletedInventoryResponse, error)
	GetInventoryBranchs(ctx context.Context, params *types.ParamsInventoryBranch) (*types.InventoryBranchsDataResponse, error)
	GetInventoryType(ctx context.Context, id *string) (*types.InventoryTypeResponse, error)
	GetInventoryTypes(ctx context.Context, params *types.ParamsInventoryType) (*types.InventoryTypesResponse, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "DeleteInventoryBranchResponse.data":
		if e.complexity.DeleteInventoryBranchResponse.Data == nil {
			break
		}

		return e.complexity.DeleteInventoryBranchResponse.Data(childComplexity), true

	case "DeleteInventoryBranchResponse.status":
		if e.complexity.DeleteInventoryBranchResponse.Status == nil {
			break
		}

		return e.complexity.DeleteInventoryBranchResponse.Status(childComplexity), true

	case "DeleteInventoryBrandResponse.data":
		if e.complexity.DeleteInventoryBrandResponse.Data == nil {
			break
		}

		return e.complexity.DeleteInventoryBrandResponse.Data(childComplexity), true

	case "DeleteInventoryBrandResponse.status":
		if e.complexity.DeleteInventoryBrandResponse.Status == nil {
			break
		}

		return e.complexity.DeleteInventoryBrandResponse.Status(childComplexity), true

	case "DeleteInventoryResponse.data":
		if e.complexity.DeleteInventoryResponse.Data == nil {
			break
		}

		return e.complexity.DeleteInventoryResponse.Data(childComplexity), true

	case "DeleteInventoryResponse.status":
		if e.complexity.DeleteInventoryResponse.Status == nil {
			break
		}

		return e.complexity.DeleteInventoryResponse.Status(childComplexity), true

	case "DeleteInventoryTypeResponse.data":
		if e.complexity.DeleteInventoryTypeResponse.Data == nil {
			break
		}

		return e.complexity.DeleteInventoryTypeResponse.Data(childComplexity), true

	case "DeleteInventoryTypeResponse.status":
		if e.complexity.DeleteInventoryTypeResponse.Status == nil {
			break
		}

		return e.complexity.DeleteInventoryTypeResponse.Status(childComplexity), true

	case "DeletedInventory.branch":
		if e.complexity.DeletedInventory.Branch == nil {
			break
		}

		return e.complexity.DeletedInventory.Branch(childComplexity), true

	case "DeletedInventory.brand":
		if e.complexity.DeletedInventory.Brand == nil {
			break
		}

		return e.complexity.DeletedInventory.Brand(childComplexity), true

	case "DeletedInventory.inventory":
		if e.complexity.DeletedInventory.Inventory == nil {
			break
		}

		return e.complexity.DeletedInventory.Inventory(childComplexity), true

	case "DeletedInventory.type":
		if e.complexity.DeletedInventory.Type == nil {
			break
		}

		return e.complexity.DeletedInventory.Type(childComplexity), true

	case "DeletedInventoryResponse.data":
		if e.complexity.DeletedInventoryResponse.Data == nil {
			break
		}

		return e.complexity.DeletedInventoryResponse.Data(childComplexity), true

	case "DeletedInventoryResponse.status":
		if e.complexity.DeletedInventoryResponse.Status == nil {
			break
		}

		return e.complexity.DeletedInventoryResponse.Status(childComplexity), true

	case "DeletedInventoryType.createdAt":
		if e.complexity.DeletedInventoryType.CreatedAt == nil {
			break
		}

		return e.complexity.DeletedInventoryType.CreatedAt(childComplexity), true

	case "DeletedInventoryType.createdBy":
		if e.complexity.DeletedInventoryType.CreatedBy == nil {
			break
		}

		return e.complexity.DeletedInventoryType.CreatedBy(childComplexity), true

	case "DeletedInventoryType.id":
		if e.complexity.DeletedInventoryType.ID == nil {
			break
		}

		return e.complexity.DeletedInventoryType.ID(childComplexity), true

	case "DeletedInventoryType.name":
		if e.complexity.DeletedInventoryType.Name == nil {
			break
		}

		return e.complexity.DeletedInventoryType.Name(childComplexity), true

	case "DeletedInventoryType.updatedAt":
		if e.complexity.DeletedInventoryType.UpdatedAt == nil {
			break
		}

		return e.complexity.DeletedInventoryType.UpdatedAt(childComplexity), true

	case "DeletedInventoryType.updatedBy":
		if e.complexity.DeletedInventoryType.UpdatedBy == nil {
			break
		}

		return e.complexity.DeletedInventoryType.UpdatedBy(childComplexity), true

	case "InventoriesResponse.data":
		if e.complexity.InventoriesResponse.Data == nil {
			break
		}

		return e.complexity.InventoriesResponse.Data(childComplexity), true

	case "InventoriesResponse.status":
		if e.complexity.InventoriesResponse.Status == nil {
			break
		}

		return e.complexity.InventoriesResponse.Status(childComplexity), true

	case "Inventory.amount":
		if e.complexity.Inventory.Amount == nil {
			break
		}

		return e.complexity.Inventory.Amount(childComplexity), true

	case "Inventory.createdAt":
		if e.complexity.Inventory.CreatedAt == nil {
			break
		}

		return e.complexity.Inventory.CreatedAt(childComplexity), true

	case "Inventory.createdBy":
		if e.complexity.Inventory.CreatedBy == nil {
			break
		}

		return e.complexity.Inventory.CreatedBy(childComplexity), true

	case "Inventory.description":
		if e.complexity.Inventory.Description == nil {
			break
		}

		return e.complexity.Inventory.Description(childComplexity), true

	case "Inventory.expiryDate":
		if e.complexity.Inventory.ExpiryDate == nil {
			break
		}

		return e.complexity.Inventory.ExpiryDate(childComplexity), true

	case "Inventory.favorite":
		if e.complexity.Inventory.Favorite == nil {
			break
		}

		return e.complexity.Inventory.Favorite(childComplexity), true

	case "Inventory.id":
		if e.complexity.Inventory.ID == nil {
			break
		}

		return e.complexity.Inventory.ID(childComplexity), true

	case "Inventory.inventoryBranch":
		if e.complexity.Inventory.InventoryBranch == nil {
			break
		}

		return e.complexity.Inventory.InventoryBranch(childComplexity), true

	case "Inventory.inventoryBrand":
		if e.complexity.Inventory.InventoryBrand == nil {
			break
		}

		return e.complexity.Inventory.InventoryBrand(childComplexity), true

	case "Inventory.inventoryType":
		if e.complexity.Inventory.InventoryType == nil {
			break
		}

		return e.complexity.Inventory.InventoryType(childComplexity), true

	case "Inventory.inventoryTypeId":
		if e.complexity.Inventory.InventoryTypeID == nil {
			break
		}

		return e.complexity.Inventory.InventoryTypeID(childComplexity), true

	case "Inventory.name":
		if e.complexity.Inventory.Name == nil {
			break
		}

		return e.complexity.Inventory.Name(childComplexity), true

	case "Inventory.price":
		if e.complexity.Inventory.Price == nil {
			break
		}

		return e.complexity.Inventory.Price(childComplexity), true

	case "Inventory.priceMember":
		if e.complexity.Inventory.PriceMember == nil {
			break
		}

		return e.complexity.Inventory.PriceMember(childComplexity), true

	case "Inventory.reorderLevel":
		if e.complexity.Inventory.ReorderLevel == nil {
			break
		}

		return e.complexity.Inventory.ReorderLevel(childComplexity), true

	case "Inventory.serialNumber":
		if e.complexity.Inventory.SerialNumber == nil {
			break
		}

		return e.complexity.Inventory.SerialNumber(childComplexity), true

	case "Inventory.size":
		if e.complexity.Inventory.Size == nil {
			break
		}

		return e.complexity.Inventory.Size(childComplexity), true

	case "Inventory.sku":
		if e.complexity.Inventory.Sku == nil {
			break
		}

		return e.complexity.Inventory.Sku(childComplexity), true

	case "Inventory.sold":
		if e.complexity.Inventory.Sold == nil {
			break
		}

		return e.complexity.Inventory.Sold(childComplexity), true

	case "Inventory.updatedAt":
		if e.complexity.Inventory.UpdatedAt == nil {
			break
		}

		return e.complexity.Inventory.UpdatedAt(childComplexity), true

	case "Inventory.updatedBy":
		if e.complexity.Inventory.UpdatedBy == nil {
			break
		}

		return e.complexity.Inventory.UpdatedBy(childComplexity), true

	case "InventoryBranch.createdAt":
		if e.complexity.InventoryBranch.CreatedAt == nil {
			break
		}

		return e.complexity.InventoryBranch.CreatedAt(childComplexity), true

	case "InventoryBranch.createdBy":
		if e.complexity.InventoryBranch.CreatedBy == nil {
			break
		}

		return e.complexity.InventoryBranch.CreatedBy(childComplexity), true

	case "InventoryBranch.description":
		if e.complexity.InventoryBranch.Description == nil {
			break
		}

		return e.complexity.InventoryBranch.Description(childComplexity), true

	case "InventoryBranch.id":
		if e.complexity.InventoryBranch.ID == nil {
			break
		}

		return e.complexity.InventoryBranch.ID(childComplexity), true

	case "InventoryBranch.name":
		if e.complexity.InventoryBranch.Name == nil {
			break
		}

		return e.complexity.InventoryBranch.Name(childComplexity), true

	case "InventoryBranch.updatedAt":
		if e.complexity.InventoryBranch.UpdatedAt == nil {
			break
		}

		return e.complexity.InventoryBranch.UpdatedAt(childComplexity), true

	case "InventoryBranch.updatedBy":
		if e.complexity.InventoryBranch.UpdatedBy == nil {
			break
		}

		return e.complexity.InventoryBranch.UpdatedBy(childComplexity), true

	case "InventoryBranchsDataResponse.data":
		if e.complexity.InventoryBranchsDataResponse.Data == nil {
			break
		}

		return e.complexity.InventoryBranchsDataResponse.Data(childComplexity), true

	case "InventoryBranchsDataResponse.status":
		if e.complexity.InventoryBranchsDataResponse.Status == nil {
			break
		}

		return e.complexity.InventoryBranchsDataResponse.Status(childComplexity), true

	case "InventoryBrand.createdAt":
		if e.complexity.InventoryBrand.CreatedAt == nil {
			break
		}

		return e.complexity.InventoryBrand.CreatedAt(childComplexity), true

	case "InventoryBrand.createdBy":
		if e.complexity.InventoryBrand.CreatedBy == nil {
			break
		}

		return e.complexity.InventoryBrand.CreatedBy(childComplexity), true

	case "InventoryBrand.description":
		if e.complexity.InventoryBrand.Description == nil {
			break
		}

		return e.complexity.InventoryBrand.Description(childComplexity), true

	case "InventoryBrand.id":
		if e.complexity.InventoryBrand.ID == nil {
			break
		}

		return e.complexity.InventoryBrand.ID(childComplexity), true

	case "InventoryBrand.name":
		if e.complexity.InventoryBrand.Name == nil {
			break
		}

		return e.complexity.InventoryBrand.Name(childComplexity), true

	case "InventoryBrand.updatedAt":
		if e.complexity.InventoryBrand.UpdatedAt == nil {
			break
		}

		return e.complexity.InventoryBrand.UpdatedAt(childComplexity), true

	case "InventoryBrand.updatedBy":
		if e.complexity.InventoryBrand.UpdatedBy == nil {
			break
		}

		return e.complexity.InventoryBrand.UpdatedBy(childComplexity), true

	case "InventoryBrandsDataResponse.data":
		if e.complexity.InventoryBrandsDataResponse.Data == nil {
			break
		}

		return e.complexity.InventoryBrandsDataResponse.Data(childComplexity), true

	case "InventoryBrandsDataResponse.status":
		if e.complexity.InventoryBrandsDataResponse.Status == nil {
			break
		}

		return e.complexity.InventoryBrandsDataResponse.Status(childComplexity), true

	case "InventoryDataResponse.data":
		if e.complexity.InventoryDataResponse.Data == nil {
			break
		}

		return e.complexity.InventoryDataResponse.Data(childComplexity), true

	case "InventoryDataResponse.status":
		if e.complexity.InventoryDataResponse.Status == nil {
			break
		}

		return e.complexity.InventoryDataResponse.Status(childComplexity), true

	case "InventoryName.id":
		if e.complexity.InventoryName.ID == nil {
			break
		}

		return e.complexity.InventoryName.ID(childComplexity), true

	case "InventoryName.name":
		if e.complexity.InventoryName.Name == nil {
			break
		}

		return e.complexity.InventoryName.Name(childComplexity), true

	case "InventoryNameResponse.data":
		if e.complexity.InventoryNameResponse.Data == nil {
			break
		}

		return e.complexity.InventoryNameResponse.Data(childComplexity), true

	case "InventoryNameResponse.status":
		if e.complexity.InventoryNameResponse.Status == nil {
			break
		}

		return e.complexity.InventoryNameResponse.Status(childComplexity), true

	case "InventoryType.createdAt":
		if e.complexity.InventoryType.CreatedAt == nil {
			break
		}

		return e.complexity.InventoryType.CreatedAt(childComplexity), true

	case "InventoryType.createdBy":
		if e.complexity.InventoryType.CreatedBy == nil {
			break
		}

		return e.complexity.InventoryType.CreatedBy(childComplexity), true

	case "InventoryType.description":
		if e.complexity.InventoryType.Description == nil {
			break
		}

		return e.complexity.InventoryType.Description(childComplexity), true

	case "InventoryType.id":
		if e.complexity.InventoryType.ID == nil {
			break
		}

		return e.complexity.InventoryType.ID(childComplexity), true

	case "InventoryType.name":
		if e.complexity.InventoryType.Name == nil {
			break
		}

		return e.complexity.InventoryType.Name(childComplexity), true

	case "InventoryType.updatedAt":
		if e.complexity.InventoryType.UpdatedAt == nil {
			break
		}

		return e.complexity.InventoryType.UpdatedAt(childComplexity), true

	case "InventoryType.updatedBy":
		if e.complexity.InventoryType.UpdatedBy == nil {
			break
		}

		return e.complexity.InventoryType.UpdatedBy(childComplexity), true

	case "InventoryTypeResponse.data":
		if e.complexity.InventoryTypeResponse.Data == nil {
			break
		}

		return e.complexity.InventoryTypeResponse.Data(childComplexity), true

	case "InventoryTypeResponse.status":
		if e.complexity.InventoryTypeResponse.Status == nil {
			break
		}

		return e.complexity.InventoryTypeResponse.Status(childComplexity), true

	case "InventoryTypesResponse.data":
		if e.complexity.InventoryTypesResponse.Data == nil {
			break
		}

		return e.complexity.InventoryTypesResponse.Data(childComplexity), true

	case "InventoryTypesResponse.status":
		if e.complexity.InventoryTypesResponse.Status == nil {
			break
		}

		return e.complexity.InventoryTypesResponse.Status(childComplexity), true

	case "Mutation.deleteInventory":
		if e.complexity.Mutation.DeleteInventory == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInventory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInventory(childComplexity, args["id"].(string)), true

	case "Mutation.deleteInventoryBranch":
		if e.complexity.Mutation.DeleteInventoryBranch == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInventoryBranch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInventoryBranch(childComplexity, args["id"].(string)), true

	case "Mutation.deleteInventoryBrand":
		if e.complexity.Mutation.DeleteInventoryBrand == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInventoryBrand_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInventoryBrand(childComplexity, args["id"].(string)), true

	case "Mutation.deleteInventoryType":
		if e.complexity.Mutation.DeleteInventoryType == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInventoryType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInventoryType(childComplexity, args["id"].(string)), true

	case "Mutation.favoriteInventory":
		if e.complexity.Mutation.FavoriteInventory == nil {
			break
		}

		args, err := ec.field_Mutation_favoriteInventory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FavoriteInventory(childComplexity, args["id"].(string)), true

	case "Mutation.recoveryHardDeleted":
		if e.complexity.Mutation.RecoveryHardDeleted == nil {
			break
		}

		args, err := ec.field_Mutation_recoveryHardDeleted_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RecoveryHardDeleted(childComplexity, args["input"].(types.RecoveryHardDeletedInput)), true

	case "Mutation.uploadInventory":
		if e.complexity.Mutation.UploadInventory == nil {
			break
		}

		args, err := ec.field_Mutation_uploadInventory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadInventory(childComplexity, args["input"].(types.UploadInventoryInput)), true

	case "Mutation.upsertInventory":
		if e.complexity.Mutation.UpsertInventory == nil {
			break
		}

		args, err := ec.field_Mutation_upsertInventory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertInventory(childComplexity, args["input"].(types.UpsertInventoryInput)), true

	case "Mutation.upsertInventoryBranch":
		if e.complexity.Mutation.UpsertInventoryBranch == nil {
			break
		}

		args, err := ec.field_Mutation_upsertInventoryBranch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertInventoryBranch(childComplexity, args["input"].(types.UpsertInventoryBranchInput)), true

	case "Mutation.upsertInventoryBrand":
		if e.complexity.Mutation.UpsertInventoryBrand == nil {
			break
		}

		args, err := ec.field_Mutation_upsertInventoryBrand_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertInventoryBrand(childComplexity, args["input"].(types.UpsertInventoryBrandInput)), true

	case "Mutation.upsertInventoryType":
		if e.complexity.Mutation.UpsertInventoryType == nil {
			break
		}

		args, err := ec.field_Mutation_upsertInventoryType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertInventoryType(childComplexity, args["input"].(types.UpsertInventoryTypeInput)), true

	case "MutationInventoryBranchResponse.data":
		if e.complexity.MutationInventoryBranchResponse.Data == nil {
			break
		}

		return e.complexity.MutationInventoryBranchResponse.Data(childComplexity), true

	case "MutationInventoryBranchResponse.status":
		if e.complexity.MutationInventoryBranchResponse.Status == nil {
			break
		}

		return e.complexity.MutationInventoryBranchResponse.Status(childComplexity), true

	case "MutationInventoryBrandResponse.data":
		if e.complexity.MutationInventoryBrandResponse.Data == nil {
			break
		}

		return e.complexity.MutationInventoryBrandResponse.Data(childComplexity), true

	case "MutationInventoryBrandResponse.status":
		if e.complexity.MutationInventoryBrandResponse.Status == nil {
			break
		}

		return e.complexity.MutationInventoryBrandResponse.Status(childComplexity), true

	case "MutationInventoryResponse.data":
		if e.complexity.MutationInventoryResponse.Data == nil {
			break
		}

		return e.complexity.MutationInventoryResponse.Data(childComplexity), true

	case "MutationInventoryResponse.status":
		if e.complexity.MutationInventoryResponse.Status == nil {
			break
		}

		return e.complexity.MutationInventoryResponse.Status(childComplexity), true

	case "MutationInventoryTypeResponse.data":
		if e.complexity.MutationInventoryTypeResponse.Data == nil {
			break
		}

		return e.complexity.MutationInventoryTypeResponse.Data(childComplexity), true

	case "MutationInventoryTypeResponse.status":
		if e.complexity.MutationInventoryTypeResponse.Status == nil {
			break
		}

		return e.complexity.MutationInventoryTypeResponse.Status(childComplexity), true

	case "Query.getInventories":
		if e.complexity.Query.GetInventories == nil {
			break
		}

		args, err := ec.field_Query_getInventories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInventories(childComplexity, args["params"].(*types.ParamsInventory)), true

	case "Query.getInventory":
		if e.complexity.Query.GetInventory == nil {
			break
		}

		args, err := ec.field_Query_getInventory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInventory(childComplexity, args["id"].(*string)), true

	case "Query.getInventoryAllDeleted":
		if e.complexity.Query.GetInventoryAllDeleted == nil {
			break
		}

		return e.complexity.Query.GetInventoryAllDeleted(childComplexity), true

	case "Query.getInventoryBranchs":
		if e.complexity.Query.GetInventoryBranchs == nil {
			break
		}

		args, err := ec.field_Query_getInventoryBranchs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInventoryBranchs(childComplexity, args["params"].(*types.ParamsInventoryBranch)), true

	case "Query.getInventoryBrand":
		if e.complexity.Query.GetInventoryBrand == nil {
			break
		}

		args, err := ec.field_Query_getInventoryBrand_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInventoryBrand(childComplexity, args["id"].(*string)), true

	case "Query.getInventoryBrands":
		if e.complexity.Query.GetInventoryBrands == nil {
			break
		}

		args, err := ec.field_Query_getInventoryBrands_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInventoryBrands(childComplexity, args["params"].(*types.ParamsInventoryBrand)), true

	case "Query.getInventoryNames":
		if e.complexity.Query.GetInventoryNames == nil {
			break
		}

		return e.complexity.Query.GetInventoryNames(childComplexity), true

	case "Query.getInventoryType":
		if e.complexity.Query.GetInventoryType == nil {
			break
		}

		args, err := ec.field_Query_getInventoryType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInventoryType(childComplexity, args["id"].(*string)), true

	case "Query.getInventoryTypes":
		if e.complexity.Query.GetInventoryTypes == nil {
			break
		}

		args, err := ec.field_Query_getInventoryTypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInventoryTypes(childComplexity, args["params"].(*types.ParamsInventoryType)), true

	case "RecoveryHardDeleted.id":
		if e.complexity.RecoveryHardDeleted.ID == nil {
			break
		}

		return e.complexity.RecoveryHardDeleted.ID(childComplexity), true

	case "RecoveryHardDeleted.mode":
		if e.complexity.RecoveryHardDeleted.Mode == nil {
			break
		}

		return e.complexity.RecoveryHardDeleted.Mode(childComplexity), true

	case "RecoveryHardDeleted.type":
		if e.complexity.RecoveryHardDeleted.Type == nil {
			break
		}

		return e.complexity.RecoveryHardDeleted.Type(childComplexity), true

	case "RecoveryHardDeletedResponse.data":
		if e.complexity.RecoveryHardDeletedResponse.Data == nil {
			break
		}

		return e.complexity.RecoveryHardDeletedResponse.Data(childComplexity), true

	case "RecoveryHardDeletedResponse.status":
		if e.complexity.RecoveryHardDeletedResponse.Status == nil {
			break
		}

		return e.complexity.RecoveryHardDeletedResponse.Status(childComplexity), true

	case "ResponseId.id":
		if e.complexity.ResponseId.ID == nil {
			break
		}

		return e.complexity.ResponseId.ID(childComplexity), true

	case "ResponseInventories.inventories":
		if e.complexity.ResponseInventories.Inventories == nil {
			break
		}

		return e.complexity.ResponseInventories.Inventories(childComplexity), true

	case "ResponseInventories.pageLimit":
		if e.complexity.ResponseInventories.PageLimit == nil {
			break
		}

		return e.complexity.ResponseInventories.PageLimit(childComplexity), true

	case "ResponseInventories.pageNo":
		if e.complexity.ResponseInventories.PageNo == nil {
			break
		}

		return e.complexity.ResponseInventories.PageNo(childComplexity), true

	case "ResponseInventories.totalPage":
		if e.complexity.ResponseInventories.TotalPage == nil {
			break
		}

		return e.complexity.ResponseInventories.TotalPage(childComplexity), true

	case "ResponseInventories.totalRow":
		if e.complexity.ResponseInventories.TotalRow == nil {
			break
		}

		return e.complexity.ResponseInventories.TotalRow(childComplexity), true

	case "Status.code":
		if e.complexity.Status.Code == nil {
			break
		}

		return e.complexity.Status.Code(childComplexity), true

	case "Status.message":
		if e.complexity.Status.Message == nil {
			break
		}

		return e.complexity.Status.Message(childComplexity), true

	case "UploadInventory.id":
		if e.complexity.UploadInventory.ID == nil {
			break
		}

		return e.complexity.UploadInventory.ID(childComplexity), true

	case "UploadInventory.reason":
		if e.complexity.UploadInventory.Reason == nil {
			break
		}

		return e.complexity.UploadInventory.Reason(childComplexity), true

	case "UploadInventory.success":
		if e.complexity.UploadInventory.Success == nil {
			break
		}

		return e.complexity.UploadInventory.Success(childComplexity), true

	case "UploadInventoryResponse.data":
		if e.complexity.UploadInventoryResponse.Data == nil {
			break
		}

		return e.complexity.UploadInventoryResponse.Data(childComplexity), true

	case "UploadInventoryResponse.status":
		if e.complexity.UploadInventoryResponse.Status == nil {
			break
		}

		return e.complexity.UploadInventoryResponse.Status(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputParamsInventory,
		ec.unmarshalInputParamsInventoryBranch,
		ec.unmarshalInputParamsInventoryBrand,
		ec.unmarshalInputParamsInventoryType,
		ec.unmarshalInputRecoveryHardDeletedInput,
		ec.unmarshalInputSizeInventory,
		ec.unmarshalInputUploadInventoryInput,
		ec.unmarshalInputUpsertInventoryBranchInput,
		ec.unmarshalInputUpsertInventoryBrandInput,
		ec.unmarshalInputUpsertInventoryInput,
		ec.unmarshalInputUpsertInventoryTypeInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema/inventory.graphqls", Input: `directive @goField(
  forceResolver: Boolean
  name: String
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# new directive
directive @auth(scopes: [String]) on FIELD_DEFINITION

scalar DateTime

enum FavoriteStatus {
  LIKE
  DEFAULT
}

enum DeletedType {
  inventory
  inventoryType
  inventoryBrand
  inventoryBranch
}

enum DeletedMode {
  RECOVERY
  DELETE
}

type Status {
  code: Int!
  message: String
}

type ResponseId {
  id: String
}

# Inventory Types
type Inventory {
  id: String
  inventoryTypeId: String
  name: String!
  amount: Int!
  sold: Int
  sku: String
  serialNumber: String
  size: String
  priceMember: Int
  price: Int!
  reorderLevel: Int
  expiryDate: String!
  inventoryBrand: InventoryBrand
  inventoryBranch: InventoryBranch
  inventoryType: InventoryType
  favorite: Boolean
  description: String
  createdBy: String
  updatedBy: String
  updatedAt: String!
  createdAt: String!
}

type InventoryDataResponse {
  data: Inventory
  status: Status
}

type InventoriesResponse {
  data: ResponseInventories
  status: Status
}

type ResponseInventories {
  inventories: [Inventory]
  pageLimit: Int
  pageNo: Int
  totalPage: Int
  totalRow: Int
}

input UpsertInventoryInput {
  id: String
  name: String!
  inventoryTypeId: String!
  inventoryBrandId: String!
  inventoryBranchId: String!
  favorite: Boolean
  amount: Int!
  sku: String
  serialNumber: String
  reorderLevel: Int
  size: SizeInventory
  price: Int!
  priceMember: Int
  expiryDate: String!
  description: String
  createdBy: String
  updatedBy: String
}

type MutationInventoryResponse {
  data: ResponseId
  status: Status
}

type DeleteInventoryResponse {
  data: ResponseId
  status: Status
}

input ParamsInventory {
  search: String
  favorite: FavoriteStatus
  type: [String]
  brand: [String]
  branch: [String]
  pageNo: Int
  limit: Int
}

input UploadInventoryInput {
  uploadDatas: [UpsertInventoryInput]
  fileName: String
}

type UploadInventoryResponse {
  data: UploadInventory
  status: Status
}

type UploadInventory {
  id: String
  success: Boolean
  reason: String
}

type DeletedInventoryResponse {
  data: DeletedInventory
  status: Status
}

type DeletedInventoryType {
  id: String
  name: String
  createdBy: String
  updatedBy: String
  updatedAt: String!
  createdAt: String!
}

type DeletedInventory {
  inventory: [DeletedInventoryType]
  brand: [DeletedInventoryType]
  branch: [DeletedInventoryType]
  type: [DeletedInventoryType]
}

input RecoveryHardDeletedInput {
  id: String!
  type: DeletedType!
  mode: DeletedMode!
}

type RecoveryHardDeleted {
  id: String
  type: DeletedType
  mode: DeletedMode
}

type RecoveryHardDeletedResponse {
  data: RecoveryHardDeleted
  status: Status
}

type InventoryName {
  id: String
  name: String
}

input SizeInventory {
  weight: Int
  width: Int
  length: Int
  height: Int
}

type InventoryNameResponse {
  data: [InventoryName]
  status: Status
}

extend type Query {
  getInventoryNames: InventoryNameResponse
  getInventory(id: String): InventoryDataResponse @auth
  getInventories(params: ParamsInventory): InventoriesResponse
  getInventoryAllDeleted: DeletedInventoryResponse
}

extend type Mutation {
  uploadInventory(input: UploadInventoryInput!): UploadInventoryResponse
  upsertInventory(input: UpsertInventoryInput!): MutationInventoryResponse
  deleteInventory(id: String!): MutationInventoryResponse
  favoriteInventory(id: String!): MutationInventoryResponse
  recoveryHardDeleted(
    input: RecoveryHardDeletedInput!
  ): RecoveryHardDeletedResponse
}
`, BuiltIn: false},
	{Name: "../../schema/inventoryBranch.graphqls", Input: `type InventoryBranch {
  id: String
  name: String
  description: String
  createdBy: String
  updatedBy: String
  updatedAt: String!
  createdAt: String!
}

type InventoryBranchsDataResponse {
  data: [InventoryBranch]
  status: Status
}

input UpsertInventoryBranchInput {
  id: String
  name: String!
  description: String
  createdBy: String
  updatedBy: String
}

type MutationInventoryBranchResponse {
  data: ResponseId
  status: Status
}

type DeleteInventoryBranchResponse {
  data: ResponseId
  status: Status
}

input ParamsInventoryBranch {
  search: String
  offset: Int
  limit: Int
}

extend type Query {
  getInventoryBranchs(
    params: ParamsInventoryBranch
  ): InventoryBranchsDataResponse
}

extend type Mutation {
  upsertInventoryBranch(
    input: UpsertInventoryBranchInput!
  ): MutationInventoryBranchResponse
  deleteInventoryBranch(id: String!): MutationInventoryBranchResponse
}
`, BuiltIn: false},
	{Name: "../../schema/inventoryBrand.graphqls", Input: `type InventoryBrand {
  id: String
  name: String
  description: String
  createdBy: String
  updatedBy: String
  updatedAt: String!
  createdAt: String!
}

type InventoryBrandsDataResponse {
  data: [InventoryBrand]
  status: Status
}

input UpsertInventoryBrandInput {
  id: String
  name: String!
  description: String
  createdBy: String
  updatedBy: String
}

type MutationInventoryBrandResponse {
  data: ResponseId
  status: Status
}

type DeleteInventoryBrandResponse {
  data: ResponseId
  status: Status
}

input ParamsInventoryBrand {
  search: String
  offset: Int
  limit: Int
}

type Query {
  getInventoryBrand(id: String): InventoryBrand
  getInventoryBrands(params: ParamsInventoryBrand): InventoryBrandsDataResponse
}

type Mutation {
  upsertInventoryBrand(
    input: UpsertInventoryBrandInput!
  ): MutationInventoryBrandResponse
  deleteInventoryBrand(id: String!): MutationInventoryBrandResponse
}
`, BuiltIn: false},
	{Name: "../../schema/inventoryType.graphqls", Input: `type InventoryType {
  id: String
  name: String
  description: String
  createdBy: String
  updatedBy: String
  updatedAt: String!
  createdAt: String!
}

type InventoryTypeResponse {
  data: InventoryType
  status: Status
}

type InventoryTypesResponse {
  data: [InventoryType]
  status: Status
}

input UpsertInventoryTypeInput {
  id: String
  name: String!
  description: String
  createdBy: String
  updatedBy: String
}

type MutationInventoryTypeResponse {
  data: ResponseId
  status: Status
}

type DeleteInventoryTypeResponse {
  data: ResponseId
  status: Status
}

input ParamsInventoryType {
  search: String
  offset: Int
  limit: Int
}

extend type Mutation {
  upsertInventoryType(
    input: UpsertInventoryTypeInput!
  ): MutationInventoryResponse @auth
  deleteInventoryType(id: String!): MutationInventoryResponse @auth
}

extend type Query {
  getInventoryType(id: String): InventoryTypeResponse @auth
  getInventoryTypes(params: ParamsInventoryType): InventoryTypesResponse
    @auth(scopes: ["MakerAdminScope"])
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_auth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["scopes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
		arg0, err = ec.unmarshalOString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scopes"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteInventoryBranch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteInventoryBrand_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteInventoryType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteInventory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_favoriteInventory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_recoveryHardDeleted_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.RecoveryHardDeletedInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRecoveryHardDeletedInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐRecoveryHardDeletedInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_uploadInventory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.UploadInventoryInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUploadInventoryInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUploadInventoryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertInventoryBranch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.UpsertInventoryBranchInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertInventoryBranchInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryBranchInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertInventoryBrand_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.UpsertInventoryBrandInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertInventoryBrandInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryBrandInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertInventoryType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.UpsertInventoryTypeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertInventoryTypeInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryTypeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertInventory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 types.UpsertInventoryInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertInventoryInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInventories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *types.ParamsInventory
	if tmp, ok := rawArgs["params"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("params"))
		arg0, err = ec.unmarshalOParamsInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventory(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInventoryBranchs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *types.ParamsInventoryBranch
	if tmp, ok := rawArgs["params"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("params"))
		arg0, err = ec.unmarshalOParamsInventoryBranch2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventoryBranch(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInventoryBrand_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInventoryBrands_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *types.ParamsInventoryBrand
	if tmp, ok := rawArgs["params"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("params"))
		arg0, err = ec.unmarshalOParamsInventoryBrand2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventoryBrand(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInventoryType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInventoryTypes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *types.ParamsInventoryType
	if tmp, ok := rawArgs["params"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("params"))
		arg0, err = ec.unmarshalOParamsInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventoryType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["params"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getInventory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _DeleteInventoryBranchResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryBranchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryBranchResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryBranchResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryBranchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteInventoryBranchResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryBranchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryBranchResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryBranchResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryBranchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteInventoryBrandResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryBrandResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryBrandResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryBrandResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryBrandResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteInventoryBrandResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryBrandResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryBrandResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryBrandResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryBrandResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteInventoryResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteInventoryResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteInventoryTypeResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryTypeResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryTypeResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryTypeResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryTypeResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteInventoryTypeResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.DeleteInventoryTypeResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteInventoryTypeResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteInventoryTypeResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteInventoryTypeResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventory_inventory(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventory_inventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inventory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.DeletedInventoryType)
	fc.Result = res
	return ec.marshalODeletedInventoryType2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventory_inventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeletedInventoryType_id(ctx, field)
			case "name":
				return ec.fieldContext_DeletedInventoryType_name(ctx, field)
			case "createdBy":
				return ec.fieldContext_DeletedInventoryType_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_DeletedInventoryType_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DeletedInventoryType_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_DeletedInventoryType_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedInventoryType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventory_brand(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventory_brand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Brand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.DeletedInventoryType)
	fc.Result = res
	return ec.marshalODeletedInventoryType2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventory_brand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeletedInventoryType_id(ctx, field)
			case "name":
				return ec.fieldContext_DeletedInventoryType_name(ctx, field)
			case "createdBy":
				return ec.fieldContext_DeletedInventoryType_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_DeletedInventoryType_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DeletedInventoryType_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_DeletedInventoryType_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedInventoryType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventory_branch(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventory_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.DeletedInventoryType)
	fc.Result = res
	return ec.marshalODeletedInventoryType2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventory_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeletedInventoryType_id(ctx, field)
			case "name":
				return ec.fieldContext_DeletedInventoryType_name(ctx, field)
			case "createdBy":
				return ec.fieldContext_DeletedInventoryType_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_DeletedInventoryType_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DeletedInventoryType_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_DeletedInventoryType_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedInventoryType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventory_type(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventory_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.DeletedInventoryType)
	fc.Result = res
	return ec.marshalODeletedInventoryType2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventory_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeletedInventoryType_id(ctx, field)
			case "name":
				return ec.fieldContext_DeletedInventoryType_name(ctx, field)
			case "createdBy":
				return ec.fieldContext_DeletedInventoryType_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_DeletedInventoryType_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DeletedInventoryType_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_DeletedInventoryType_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedInventoryType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.DeletedInventory)
	fc.Result = res
	return ec.marshalODeletedInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inventory":
				return ec.fieldContext_DeletedInventory_inventory(ctx, field)
			case "brand":
				return ec.fieldContext_DeletedInventory_brand(ctx, field)
			case "branch":
				return ec.fieldContext_DeletedInventory_branch(ctx, field)
			case "type":
				return ec.fieldContext_DeletedInventory_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedInventory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryType_id(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryType_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryType_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryType_name(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryType_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryType_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryType_createdBy(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryType_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryType_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryType_updatedBy(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryType_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryType_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryType_updatedAt(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryType_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryType_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedInventoryType_createdAt(ctx context.Context, field graphql.CollectedField, obj *types.DeletedInventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedInventoryType_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedInventoryType_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedInventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoriesResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.InventoriesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoriesResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseInventories)
	fc.Result = res
	return ec.marshalOResponseInventories2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseInventories(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoriesResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoriesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inventories":
				return ec.fieldContext_ResponseInventories_inventories(ctx, field)
			case "pageLimit":
				return ec.fieldContext_ResponseInventories_pageLimit(ctx, field)
			case "pageNo":
				return ec.fieldContext_ResponseInventories_pageNo(ctx, field)
			case "totalPage":
				return ec.fieldContext_ResponseInventories_totalPage(ctx, field)
			case "totalRow":
				return ec.fieldContext_ResponseInventories_totalRow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseInventories", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoriesResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.InventoriesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoriesResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoriesResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoriesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_id(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_inventoryTypeId(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_inventoryTypeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InventoryTypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_inventoryTypeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_name(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_amount(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_amount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_sold(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_sold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_sold(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_sku(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_sku(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sku, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_sku(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_serialNumber(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_serialNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SerialNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_serialNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_size(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_priceMember(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_priceMember(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriceMember, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_priceMember(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_price(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_price(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_price(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_reorderLevel(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_reorderLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReorderLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_reorderLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_expiryDate(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_expiryDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiryDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_expiryDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_inventoryBrand(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_inventoryBrand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InventoryBrand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryBrand)
	fc.Result = res
	return ec.marshalOInventoryBrand2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_inventoryBrand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryBrand_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryBrand_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryBrand_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryBrand_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryBrand_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryBrand_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryBrand_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryBrand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_inventoryBranch(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_inventoryBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InventoryBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryBranch)
	fc.Result = res
	return ec.marshalOInventoryBranch2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBranch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_inventoryBranch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryBranch_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryBranch_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryBranch_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryBranch_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryBranch_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryBranch_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryBranch_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryBranch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_inventoryType(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_inventoryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InventoryType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryType)
	fc.Result = res
	return ec.marshalOInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_inventoryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryType_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryType_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryType_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryType_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryType_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryType_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryType_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_favorite(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_favorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Favorite, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_favorite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_description(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_createdBy(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_updatedBy(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_updatedAt(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inventory_createdAt(ctx context.Context, field graphql.CollectedField, obj *types.Inventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inventory_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inventory_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranch_id(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranch_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranch_name(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranch_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranch_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranch_description(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranch_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranch_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranch_createdBy(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranch_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranch_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranch_updatedBy(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranch_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranch_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranch_updatedAt(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranch_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranch_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranch_createdAt(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranch_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranch_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranchsDataResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranchsDataResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranchsDataResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.InventoryBranch)
	fc.Result = res
	return ec.marshalOInventoryBranch2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBranch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranchsDataResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranchsDataResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryBranch_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryBranch_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryBranch_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryBranch_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryBranch_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryBranch_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryBranch_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryBranch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBranchsDataResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBranchsDataResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBranchsDataResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBranchsDataResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBranchsDataResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrand_id(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrand_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrand_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrand_name(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrand_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrand_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrand_description(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrand_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrand_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrand_createdBy(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrand_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrand_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrand_updatedBy(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrand_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrand_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrand_updatedAt(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrand_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrand_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrand_createdAt(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrand_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrand_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrandsDataResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrandsDataResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrandsDataResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.InventoryBrand)
	fc.Result = res
	return ec.marshalOInventoryBrand2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrandsDataResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrandsDataResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryBrand_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryBrand_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryBrand_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryBrand_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryBrand_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryBrand_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryBrand_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryBrand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryBrandsDataResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.InventoryBrandsDataResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryBrandsDataResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryBrandsDataResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryBrandsDataResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryDataResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.InventoryDataResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryDataResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Inventory)
	fc.Result = res
	return ec.marshalOInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryDataResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryDataResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inventory_id(ctx, field)
			case "inventoryTypeId":
				return ec.fieldContext_Inventory_inventoryTypeId(ctx, field)
			case "name":
				return ec.fieldContext_Inventory_name(ctx, field)
			case "amount":
				return ec.fieldContext_Inventory_amount(ctx, field)
			case "sold":
				return ec.fieldContext_Inventory_sold(ctx, field)
			case "sku":
				return ec.fieldContext_Inventory_sku(ctx, field)
			case "serialNumber":
				return ec.fieldContext_Inventory_serialNumber(ctx, field)
			case "size":
				return ec.fieldContext_Inventory_size(ctx, field)
			case "priceMember":
				return ec.fieldContext_Inventory_priceMember(ctx, field)
			case "price":
				return ec.fieldContext_Inventory_price(ctx, field)
			case "reorderLevel":
				return ec.fieldContext_Inventory_reorderLevel(ctx, field)
			case "expiryDate":
				return ec.fieldContext_Inventory_expiryDate(ctx, field)
			case "inventoryBrand":
				return ec.fieldContext_Inventory_inventoryBrand(ctx, field)
			case "inventoryBranch":
				return ec.fieldContext_Inventory_inventoryBranch(ctx, field)
			case "inventoryType":
				return ec.fieldContext_Inventory_inventoryType(ctx, field)
			case "favorite":
				return ec.fieldContext_Inventory_favorite(ctx, field)
			case "description":
				return ec.fieldContext_Inventory_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_Inventory_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Inventory_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inventory_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inventory_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inventory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryDataResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.InventoryDataResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryDataResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryDataResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryDataResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryName_id(ctx context.Context, field graphql.CollectedField, obj *types.InventoryName) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryName_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryName_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryName",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryName_name(ctx context.Context, field graphql.CollectedField, obj *types.InventoryName) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryName_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryName_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryName",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryNameResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.InventoryNameResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryNameResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.InventoryName)
	fc.Result = res
	return ec.marshalOInventoryName2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryNameResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryNameResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryName_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryName_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryName", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryNameResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.InventoryNameResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryNameResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryNameResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryNameResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryType_id(ctx context.Context, field graphql.CollectedField, obj *types.InventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryType_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryType_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryType_name(ctx context.Context, field graphql.CollectedField, obj *types.InventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryType_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryType_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryType_description(ctx context.Context, field graphql.CollectedField, obj *types.InventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryType_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryType_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryType_createdBy(ctx context.Context, field graphql.CollectedField, obj *types.InventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryType_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryType_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryType_updatedBy(ctx context.Context, field graphql.CollectedField, obj *types.InventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryType_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryType_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryType_updatedAt(ctx context.Context, field graphql.CollectedField, obj *types.InventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryType_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryType_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryType_createdAt(ctx context.Context, field graphql.CollectedField, obj *types.InventoryType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryType_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryType_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryTypeResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.InventoryTypeResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryTypeResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryType)
	fc.Result = res
	return ec.marshalOInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryTypeResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryTypeResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryType_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryType_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryType_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryType_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryType_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryType_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryType_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryTypeResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.InventoryTypeResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryTypeResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryTypeResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryTypeResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryTypesResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.InventoryTypesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryTypesResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.InventoryType)
	fc.Result = res
	return ec.marshalOInventoryType2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryTypesResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryTypesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryType_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryType_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryType_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryType_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryType_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryType_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryType_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InventoryTypesResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.InventoryTypesResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InventoryTypesResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InventoryTypesResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InventoryTypesResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertInventoryBrand(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertInventoryBrand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertInventoryBrand(rctx, fc.Args["input"].(types.UpsertInventoryBrandInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryBrandResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryBrandResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryBrandResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertInventoryBrand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryBrandResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryBrandResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryBrandResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertInventoryBrand_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteInventoryBrand(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteInventoryBrand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteInventoryBrand(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryBrandResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryBrandResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryBrandResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteInventoryBrand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryBrandResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryBrandResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryBrandResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteInventoryBrand_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadInventory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadInventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UploadInventory(rctx, fc.Args["input"].(types.UploadInventoryInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.UploadInventoryResponse)
	fc.Result = res
	return ec.marshalOUploadInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUploadInventoryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadInventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_UploadInventoryResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_UploadInventoryResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UploadInventoryResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadInventory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertInventory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertInventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertInventory(rctx, fc.Args["input"].(types.UpsertInventoryInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertInventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertInventory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteInventory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteInventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteInventory(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteInventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteInventory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_favoriteInventory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_favoriteInventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FavoriteInventory(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_favoriteInventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_favoriteInventory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_recoveryHardDeleted(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_recoveryHardDeleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RecoveryHardDeleted(rctx, fc.Args["input"].(types.RecoveryHardDeletedInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.RecoveryHardDeletedResponse)
	fc.Result = res
	return ec.marshalORecoveryHardDeletedResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐRecoveryHardDeletedResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_recoveryHardDeleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_RecoveryHardDeletedResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_RecoveryHardDeletedResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecoveryHardDeletedResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_recoveryHardDeleted_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertInventoryBranch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertInventoryBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertInventoryBranch(rctx, fc.Args["input"].(types.UpsertInventoryBranchInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryBranchResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryBranchResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryBranchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertInventoryBranch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryBranchResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryBranchResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryBranchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertInventoryBranch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteInventoryBranch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteInventoryBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteInventoryBranch(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryBranchResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryBranchResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryBranchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteInventoryBranch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryBranchResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryBranchResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryBranchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteInventoryBranch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertInventoryType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertInventoryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpsertInventoryType(rctx, fc.Args["input"].(types.UpsertInventoryTypeInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*types.MutationInventoryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *march-inventory/cmd/app/graph/types.MutationInventoryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertInventoryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertInventoryType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteInventoryType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteInventoryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteInventoryType(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*types.MutationInventoryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *march-inventory/cmd/app/graph/types.MutationInventoryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.MutationInventoryResponse)
	fc.Result = res
	return ec.marshalOMutationInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteInventoryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_MutationInventoryResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_MutationInventoryResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MutationInventoryResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteInventoryType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryBranchResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryBranchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryBranchResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryBranchResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryBranchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryBranchResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryBranchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryBranchResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryBranchResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryBranchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryBrandResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryBrandResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryBrandResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryBrandResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryBrandResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryBrandResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryBrandResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryBrandResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryBrandResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryBrandResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryTypeResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryTypeResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryTypeResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ResponseID)
	fc.Result = res
	return ec.marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryTypeResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryTypeResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ResponseId_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResponseId", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MutationInventoryTypeResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.MutationInventoryTypeResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MutationInventoryTypeResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MutationInventoryTypeResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MutationInventoryTypeResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventoryBrand(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventoryBrand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetInventoryBrand(rctx, fc.Args["id"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryBrand)
	fc.Result = res
	return ec.marshalOInventoryBrand2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventoryBrand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InventoryBrand_id(ctx, field)
			case "name":
				return ec.fieldContext_InventoryBrand_name(ctx, field)
			case "description":
				return ec.fieldContext_InventoryBrand_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_InventoryBrand_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_InventoryBrand_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_InventoryBrand_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_InventoryBrand_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryBrand", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInventoryBrand_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventoryBrands(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventoryBrands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetInventoryBrands(rctx, fc.Args["params"].(*types.ParamsInventoryBrand))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryBrandsDataResponse)
	fc.Result = res
	return ec.marshalOInventoryBrandsDataResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrandsDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventoryBrands(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_InventoryBrandsDataResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_InventoryBrandsDataResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryBrandsDataResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInventoryBrands_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventoryNames(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventoryNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetInventoryNames(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryNameResponse)
	fc.Result = res
	return ec.marshalOInventoryNameResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryNameResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventoryNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_InventoryNameResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_InventoryNameResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryNameResponse", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInventory(rctx, fc.Args["id"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*types.InventoryDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *march-inventory/cmd/app/graph/types.InventoryDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryDataResponse)
	fc.Result = res
	return ec.marshalOInventoryDataResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_InventoryDataResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_InventoryDataResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryDataResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInventory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetInventories(rctx, fc.Args["params"].(*types.ParamsInventory))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoriesResponse)
	fc.Result = res
	return ec.marshalOInventoriesResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoriesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_InventoriesResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_InventoriesResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoriesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInventories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventoryAllDeleted(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventoryAllDeleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetInventoryAllDeleted(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.DeletedInventoryResponse)
	fc.Result = res
	return ec.marshalODeletedInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventoryAllDeleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_DeletedInventoryResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_DeletedInventoryResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedInventoryResponse", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventoryBranchs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventoryBranchs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetInventoryBranchs(rctx, fc.Args["params"].(*types.ParamsInventoryBranch))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryBranchsDataResponse)
	fc.Result = res
	return ec.marshalOInventoryBranchsDataResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBranchsDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventoryBranchs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_InventoryBranchsDataResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_InventoryBranchsDataResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryBranchsDataResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInventoryBranchs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventoryType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventoryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInventoryType(rctx, fc.Args["id"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*types.InventoryTypeResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *march-inventory/cmd/app/graph/types.InventoryTypeResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryTypeResponse)
	fc.Result = res
	return ec.marshalOInventoryTypeResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryTypeResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventoryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_InventoryTypeResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_InventoryTypeResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryTypeResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInventoryType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInventoryTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInventoryTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInventoryTypes(rctx, fc.Args["params"].(*types.ParamsInventoryType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			scopes, err := ec.unmarshalOString2ᚕᚖstring(ctx, []interface{}{"MakerAdminScope"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, scopes)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*types.InventoryTypesResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *march-inventory/cmd/app/graph/types.InventoryTypesResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.InventoryTypesResponse)
	fc.Result = res
	return ec.marshalOInventoryTypesResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryTypesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInventoryTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_InventoryTypesResponse_data(ctx, field)
			case "status":
				return ec.fieldContext_InventoryTypesResponse_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InventoryTypesResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInventoryTypes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecoveryHardDeleted_id(ctx context.Context, field graphql.CollectedField, obj *types.RecoveryHardDeleted) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecoveryHardDeleted_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecoveryHardDeleted_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecoveryHardDeleted",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecoveryHardDeleted_type(ctx context.Context, field graphql.CollectedField, obj *types.RecoveryHardDeleted) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecoveryHardDeleted_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.DeletedType)
	fc.Result = res
	return ec.marshalODeletedType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecoveryHardDeleted_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecoveryHardDeleted",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecoveryHardDeleted_mode(ctx context.Context, field graphql.CollectedField, obj *types.RecoveryHardDeleted) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecoveryHardDeleted_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.DeletedMode)
	fc.Result = res
	return ec.marshalODeletedMode2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecoveryHardDeleted_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecoveryHardDeleted",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecoveryHardDeletedResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.RecoveryHardDeletedResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecoveryHardDeletedResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.RecoveryHardDeleted)
	fc.Result = res
	return ec.marshalORecoveryHardDeleted2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐRecoveryHardDeleted(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecoveryHardDeletedResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecoveryHardDeletedResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RecoveryHardDeleted_id(ctx, field)
			case "type":
				return ec.fieldContext_RecoveryHardDeleted_type(ctx, field)
			case "mode":
				return ec.fieldContext_RecoveryHardDeleted_mode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RecoveryHardDeleted", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RecoveryHardDeletedResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.RecoveryHardDeletedResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RecoveryHardDeletedResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RecoveryHardDeletedResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RecoveryHardDeletedResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResponseId_id(ctx context.Context, field graphql.CollectedField, obj *types.ResponseID) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResponseId_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResponseId_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResponseId",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResponseInventories_inventories(ctx context.Context, field graphql.CollectedField, obj *types.ResponseInventories) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResponseInventories_inventories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inventories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.Inventory)
	fc.Result = res
	return ec.marshalOInventory2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResponseInventories_inventories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResponseInventories",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inventory_id(ctx, field)
			case "inventoryTypeId":
				return ec.fieldContext_Inventory_inventoryTypeId(ctx, field)
			case "name":
				return ec.fieldContext_Inventory_name(ctx, field)
			case "amount":
				return ec.fieldContext_Inventory_amount(ctx, field)
			case "sold":
				return ec.fieldContext_Inventory_sold(ctx, field)
			case "sku":
				return ec.fieldContext_Inventory_sku(ctx, field)
			case "serialNumber":
				return ec.fieldContext_Inventory_serialNumber(ctx, field)
			case "size":
				return ec.fieldContext_Inventory_size(ctx, field)
			case "priceMember":
				return ec.fieldContext_Inventory_priceMember(ctx, field)
			case "price":
				return ec.fieldContext_Inventory_price(ctx, field)
			case "reorderLevel":
				return ec.fieldContext_Inventory_reorderLevel(ctx, field)
			case "expiryDate":
				return ec.fieldContext_Inventory_expiryDate(ctx, field)
			case "inventoryBrand":
				return ec.fieldContext_Inventory_inventoryBrand(ctx, field)
			case "inventoryBranch":
				return ec.fieldContext_Inventory_inventoryBranch(ctx, field)
			case "inventoryType":
				return ec.fieldContext_Inventory_inventoryType(ctx, field)
			case "favorite":
				return ec.fieldContext_Inventory_favorite(ctx, field)
			case "description":
				return ec.fieldContext_Inventory_description(ctx, field)
			case "createdBy":
				return ec.fieldContext_Inventory_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Inventory_updatedBy(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inventory_updatedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inventory_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inventory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResponseInventories_pageLimit(ctx context.Context, field graphql.CollectedField, obj *types.ResponseInventories) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResponseInventories_pageLimit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageLimit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResponseInventories_pageLimit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResponseInventories",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResponseInventories_pageNo(ctx context.Context, field graphql.CollectedField, obj *types.ResponseInventories) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResponseInventories_pageNo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageNo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResponseInventories_pageNo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResponseInventories",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResponseInventories_totalPage(ctx context.Context, field graphql.CollectedField, obj *types.ResponseInventories) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResponseInventories_totalPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResponseInventories_totalPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResponseInventories",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResponseInventories_totalRow(ctx context.Context, field graphql.CollectedField, obj *types.ResponseInventories) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResponseInventories_totalRow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResponseInventories_totalRow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResponseInventories",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_code(ctx context.Context, field graphql.CollectedField, obj *types.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_message(ctx context.Context, field graphql.CollectedField, obj *types.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadInventory_id(ctx context.Context, field graphql.CollectedField, obj *types.UploadInventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UploadInventory_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UploadInventory_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadInventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadInventory_success(ctx context.Context, field graphql.CollectedField, obj *types.UploadInventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UploadInventory_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UploadInventory_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadInventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadInventory_reason(ctx context.Context, field graphql.CollectedField, obj *types.UploadInventory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UploadInventory_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UploadInventory_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadInventory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadInventoryResponse_data(ctx context.Context, field graphql.CollectedField, obj *types.UploadInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UploadInventoryResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.UploadInventory)
	fc.Result = res
	return ec.marshalOUploadInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUploadInventory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UploadInventoryResponse_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UploadInventory_id(ctx, field)
			case "success":
				return ec.fieldContext_UploadInventory_success(ctx, field)
			case "reason":
				return ec.fieldContext_UploadInventory_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UploadInventory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadInventoryResponse_status(ctx context.Context, field graphql.CollectedField, obj *types.UploadInventoryResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UploadInventoryResponse_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UploadInventoryResponse_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadInventoryResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "code":
				return ec.fieldContext_Status_code(ctx, field)
			case "message":
				return ec.fieldContext_Status_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputParamsInventory(ctx context.Context, obj interface{}) (types.ParamsInventory, error) {
	var it types.ParamsInventory
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"search", "favorite", "type", "brand", "branch", "pageNo", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "favorite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("favorite"))
			data, err := ec.unmarshalOFavoriteStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐFavoriteStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Favorite = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "brand":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("brand"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Brand = data
		case "branch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branch"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Branch = data
		case "pageNo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageNo"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageNo = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParamsInventoryBranch(ctx context.Context, obj interface{}) (types.ParamsInventoryBranch, error) {
	var it types.ParamsInventoryBranch
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"search", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParamsInventoryBrand(ctx context.Context, obj interface{}) (types.ParamsInventoryBrand, error) {
	var it types.ParamsInventoryBrand
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"search", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParamsInventoryType(ctx context.Context, obj interface{}) (types.ParamsInventoryType, error) {
	var it types.ParamsInventoryType
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"search", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRecoveryHardDeletedInput(ctx context.Context, obj interface{}) (types.RecoveryHardDeletedInput, error) {
	var it types.RecoveryHardDeletedInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "type", "mode"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNDeletedType2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalNDeletedMode2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSizeInventory(ctx context.Context, obj interface{}) (types.SizeInventory, error) {
	var it types.SizeInventory
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"weight", "width", "length", "height"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = data
		case "length":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("length"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Length = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUploadInventoryInput(ctx context.Context, obj interface{}) (types.UploadInventoryInput, error) {
	var it types.UploadInventoryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"uploadDatas", "fileName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "uploadDatas":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uploadDatas"))
			data, err := ec.unmarshalOUpsertInventoryInput2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.UploadDatas = data
		case "fileName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertInventoryBranchInput(ctx context.Context, obj interface{}) (types.UpsertInventoryBranchInput, error) {
	var it types.UpsertInventoryBranchInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "createdBy", "updatedBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertInventoryBrandInput(ctx context.Context, obj interface{}) (types.UpsertInventoryBrandInput, error) {
	var it types.UpsertInventoryBrandInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "createdBy", "updatedBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertInventoryInput(ctx context.Context, obj interface{}) (types.UpsertInventoryInput, error) {
	var it types.UpsertInventoryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "inventoryTypeId", "inventoryBrandId", "inventoryBranchId", "favorite", "amount", "sku", "serialNumber", "reorderLevel", "size", "price", "priceMember", "expiryDate", "description", "createdBy", "updatedBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "inventoryTypeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inventoryTypeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InventoryTypeID = data
		case "inventoryBrandId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inventoryBrandId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InventoryBrandID = data
		case "inventoryBranchId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("inventoryBranchId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InventoryBranchID = data
		case "favorite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("favorite"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Favorite = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		case "sku":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sku"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sku = data
		case "serialNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serialNumber"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SerialNumber = data
		case "reorderLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reorderLevel"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReorderLevel = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOSizeInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐSizeInventory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Price = data
		case "priceMember":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceMember"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PriceMember = data
		case "expiryDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiryDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiryDate = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertInventoryTypeInput(ctx context.Context, obj interface{}) (types.UpsertInventoryTypeInput, error) {
	var it types.UpsertInventoryTypeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "createdBy", "updatedBy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var deleteInventoryBranchResponseImplementors = []string{"DeleteInventoryBranchResponse"}

func (ec *executionContext) _DeleteInventoryBranchResponse(ctx context.Context, sel ast.SelectionSet, obj *types.DeleteInventoryBranchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteInventoryBranchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteInventoryBranchResponse")
		case "data":
			out.Values[i] = ec._DeleteInventoryBranchResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._DeleteInventoryBranchResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteInventoryBrandResponseImplementors = []string{"DeleteInventoryBrandResponse"}

func (ec *executionContext) _DeleteInventoryBrandResponse(ctx context.Context, sel ast.SelectionSet, obj *types.DeleteInventoryBrandResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteInventoryBrandResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteInventoryBrandResponse")
		case "data":
			out.Values[i] = ec._DeleteInventoryBrandResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._DeleteInventoryBrandResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteInventoryResponseImplementors = []string{"DeleteInventoryResponse"}

func (ec *executionContext) _DeleteInventoryResponse(ctx context.Context, sel ast.SelectionSet, obj *types.DeleteInventoryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteInventoryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteInventoryResponse")
		case "data":
			out.Values[i] = ec._DeleteInventoryResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._DeleteInventoryResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteInventoryTypeResponseImplementors = []string{"DeleteInventoryTypeResponse"}

func (ec *executionContext) _DeleteInventoryTypeResponse(ctx context.Context, sel ast.SelectionSet, obj *types.DeleteInventoryTypeResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteInventoryTypeResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteInventoryTypeResponse")
		case "data":
			out.Values[i] = ec._DeleteInventoryTypeResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._DeleteInventoryTypeResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deletedInventoryImplementors = []string{"DeletedInventory"}

func (ec *executionContext) _DeletedInventory(ctx context.Context, sel ast.SelectionSet, obj *types.DeletedInventory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletedInventoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletedInventory")
		case "inventory":
			out.Values[i] = ec._DeletedInventory_inventory(ctx, field, obj)
		case "brand":
			out.Values[i] = ec._DeletedInventory_brand(ctx, field, obj)
		case "branch":
			out.Values[i] = ec._DeletedInventory_branch(ctx, field, obj)
		case "type":
			out.Values[i] = ec._DeletedInventory_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deletedInventoryResponseImplementors = []string{"DeletedInventoryResponse"}

func (ec *executionContext) _DeletedInventoryResponse(ctx context.Context, sel ast.SelectionSet, obj *types.DeletedInventoryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletedInventoryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletedInventoryResponse")
		case "data":
			out.Values[i] = ec._DeletedInventoryResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._DeletedInventoryResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deletedInventoryTypeImplementors = []string{"DeletedInventoryType"}

func (ec *executionContext) _DeletedInventoryType(ctx context.Context, sel ast.SelectionSet, obj *types.DeletedInventoryType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletedInventoryTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletedInventoryType")
		case "id":
			out.Values[i] = ec._DeletedInventoryType_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._DeletedInventoryType_name(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._DeletedInventoryType_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._DeletedInventoryType_updatedBy(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._DeletedInventoryType_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._DeletedInventoryType_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoriesResponseImplementors = []string{"InventoriesResponse"}

func (ec *executionContext) _InventoriesResponse(ctx context.Context, sel ast.SelectionSet, obj *types.InventoriesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoriesResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoriesResponse")
		case "data":
			out.Values[i] = ec._InventoriesResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._InventoriesResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryImplementors = []string{"Inventory"}

func (ec *executionContext) _Inventory(ctx context.Context, sel ast.SelectionSet, obj *types.Inventory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Inventory")
		case "id":
			out.Values[i] = ec._Inventory_id(ctx, field, obj)
		case "inventoryTypeId":
			out.Values[i] = ec._Inventory_inventoryTypeId(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Inventory_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "amount":
			out.Values[i] = ec._Inventory_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sold":
			out.Values[i] = ec._Inventory_sold(ctx, field, obj)
		case "sku":
			out.Values[i] = ec._Inventory_sku(ctx, field, obj)
		case "serialNumber":
			out.Values[i] = ec._Inventory_serialNumber(ctx, field, obj)
		case "size":
			out.Values[i] = ec._Inventory_size(ctx, field, obj)
		case "priceMember":
			out.Values[i] = ec._Inventory_priceMember(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Inventory_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reorderLevel":
			out.Values[i] = ec._Inventory_reorderLevel(ctx, field, obj)
		case "expiryDate":
			out.Values[i] = ec._Inventory_expiryDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "inventoryBrand":
			out.Values[i] = ec._Inventory_inventoryBrand(ctx, field, obj)
		case "inventoryBranch":
			out.Values[i] = ec._Inventory_inventoryBranch(ctx, field, obj)
		case "inventoryType":
			out.Values[i] = ec._Inventory_inventoryType(ctx, field, obj)
		case "favorite":
			out.Values[i] = ec._Inventory_favorite(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Inventory_description(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Inventory_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Inventory_updatedBy(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Inventory_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Inventory_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryBranchImplementors = []string{"InventoryBranch"}

func (ec *executionContext) _InventoryBranch(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryBranch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryBranchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryBranch")
		case "id":
			out.Values[i] = ec._InventoryBranch_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._InventoryBranch_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._InventoryBranch_description(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._InventoryBranch_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._InventoryBranch_updatedBy(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._InventoryBranch_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._InventoryBranch_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryBranchsDataResponseImplementors = []string{"InventoryBranchsDataResponse"}

func (ec *executionContext) _InventoryBranchsDataResponse(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryBranchsDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryBranchsDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryBranchsDataResponse")
		case "data":
			out.Values[i] = ec._InventoryBranchsDataResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._InventoryBranchsDataResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryBrandImplementors = []string{"InventoryBrand"}

func (ec *executionContext) _InventoryBrand(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryBrand) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryBrandImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryBrand")
		case "id":
			out.Values[i] = ec._InventoryBrand_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._InventoryBrand_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._InventoryBrand_description(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._InventoryBrand_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._InventoryBrand_updatedBy(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._InventoryBrand_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._InventoryBrand_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryBrandsDataResponseImplementors = []string{"InventoryBrandsDataResponse"}

func (ec *executionContext) _InventoryBrandsDataResponse(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryBrandsDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryBrandsDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryBrandsDataResponse")
		case "data":
			out.Values[i] = ec._InventoryBrandsDataResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._InventoryBrandsDataResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryDataResponseImplementors = []string{"InventoryDataResponse"}

func (ec *executionContext) _InventoryDataResponse(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryDataResponse")
		case "data":
			out.Values[i] = ec._InventoryDataResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._InventoryDataResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryNameImplementors = []string{"InventoryName"}

func (ec *executionContext) _InventoryName(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryName) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryNameImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryName")
		case "id":
			out.Values[i] = ec._InventoryName_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._InventoryName_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryNameResponseImplementors = []string{"InventoryNameResponse"}

func (ec *executionContext) _InventoryNameResponse(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryNameResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryNameResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryNameResponse")
		case "data":
			out.Values[i] = ec._InventoryNameResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._InventoryNameResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryTypeImplementors = []string{"InventoryType"}

func (ec *executionContext) _InventoryType(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryType")
		case "id":
			out.Values[i] = ec._InventoryType_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._InventoryType_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._InventoryType_description(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._InventoryType_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._InventoryType_updatedBy(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._InventoryType_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._InventoryType_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryTypeResponseImplementors = []string{"InventoryTypeResponse"}

func (ec *executionContext) _InventoryTypeResponse(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryTypeResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryTypeResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryTypeResponse")
		case "data":
			out.Values[i] = ec._InventoryTypeResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._InventoryTypeResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inventoryTypesResponseImplementors = []string{"InventoryTypesResponse"}

func (ec *executionContext) _InventoryTypesResponse(ctx context.Context, sel ast.SelectionSet, obj *types.InventoryTypesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inventoryTypesResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InventoryTypesResponse")
		case "data":
			out.Values[i] = ec._InventoryTypesResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._InventoryTypesResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "upsertInventoryBrand":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertInventoryBrand(ctx, field)
			})
		case "deleteInventoryBrand":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteInventoryBrand(ctx, field)
			})
		case "uploadInventory":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadInventory(ctx, field)
			})
		case "upsertInventory":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertInventory(ctx, field)
			})
		case "deleteInventory":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteInventory(ctx, field)
			})
		case "favoriteInventory":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_favoriteInventory(ctx, field)
			})
		case "recoveryHardDeleted":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_recoveryHardDeleted(ctx, field)
			})
		case "upsertInventoryBranch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertInventoryBranch(ctx, field)
			})
		case "deleteInventoryBranch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteInventoryBranch(ctx, field)
			})
		case "upsertInventoryType":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertInventoryType(ctx, field)
			})
		case "deleteInventoryType":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteInventoryType(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationInventoryBranchResponseImplementors = []string{"MutationInventoryBranchResponse"}

func (ec *executionContext) _MutationInventoryBranchResponse(ctx context.Context, sel ast.SelectionSet, obj *types.MutationInventoryBranchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationInventoryBranchResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MutationInventoryBranchResponse")
		case "data":
			out.Values[i] = ec._MutationInventoryBranchResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._MutationInventoryBranchResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationInventoryBrandResponseImplementors = []string{"MutationInventoryBrandResponse"}

func (ec *executionContext) _MutationInventoryBrandResponse(ctx context.Context, sel ast.SelectionSet, obj *types.MutationInventoryBrandResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationInventoryBrandResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MutationInventoryBrandResponse")
		case "data":
			out.Values[i] = ec._MutationInventoryBrandResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._MutationInventoryBrandResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationInventoryResponseImplementors = []string{"MutationInventoryResponse"}

func (ec *executionContext) _MutationInventoryResponse(ctx context.Context, sel ast.SelectionSet, obj *types.MutationInventoryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationInventoryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MutationInventoryResponse")
		case "data":
			out.Values[i] = ec._MutationInventoryResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._MutationInventoryResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationInventoryTypeResponseImplementors = []string{"MutationInventoryTypeResponse"}

func (ec *executionContext) _MutationInventoryTypeResponse(ctx context.Context, sel ast.SelectionSet, obj *types.MutationInventoryTypeResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationInventoryTypeResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MutationInventoryTypeResponse")
		case "data":
			out.Values[i] = ec._MutationInventoryTypeResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._MutationInventoryTypeResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getInventoryBrand":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventoryBrand(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventoryBrands":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventoryBrands(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventoryNames":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventoryNames(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventory(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventories":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventories(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventoryAllDeleted":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventoryAllDeleted(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventoryBranchs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventoryBranchs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventoryType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventoryType(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInventoryTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInventoryTypes(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recoveryHardDeletedImplementors = []string{"RecoveryHardDeleted"}

func (ec *executionContext) _RecoveryHardDeleted(ctx context.Context, sel ast.SelectionSet, obj *types.RecoveryHardDeleted) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recoveryHardDeletedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RecoveryHardDeleted")
		case "id":
			out.Values[i] = ec._RecoveryHardDeleted_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._RecoveryHardDeleted_type(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._RecoveryHardDeleted_mode(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recoveryHardDeletedResponseImplementors = []string{"RecoveryHardDeletedResponse"}

func (ec *executionContext) _RecoveryHardDeletedResponse(ctx context.Context, sel ast.SelectionSet, obj *types.RecoveryHardDeletedResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recoveryHardDeletedResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RecoveryHardDeletedResponse")
		case "data":
			out.Values[i] = ec._RecoveryHardDeletedResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._RecoveryHardDeletedResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseIdImplementors = []string{"ResponseId"}

func (ec *executionContext) _ResponseId(ctx context.Context, sel ast.SelectionSet, obj *types.ResponseID) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseIdImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResponseId")
		case "id":
			out.Values[i] = ec._ResponseId_id(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseInventoriesImplementors = []string{"ResponseInventories"}

func (ec *executionContext) _ResponseInventories(ctx context.Context, sel ast.SelectionSet, obj *types.ResponseInventories) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseInventoriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResponseInventories")
		case "inventories":
			out.Values[i] = ec._ResponseInventories_inventories(ctx, field, obj)
		case "pageLimit":
			out.Values[i] = ec._ResponseInventories_pageLimit(ctx, field, obj)
		case "pageNo":
			out.Values[i] = ec._ResponseInventories_pageNo(ctx, field, obj)
		case "totalPage":
			out.Values[i] = ec._ResponseInventories_totalPage(ctx, field, obj)
		case "totalRow":
			out.Values[i] = ec._ResponseInventories_totalRow(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var statusImplementors = []string{"Status"}

func (ec *executionContext) _Status(ctx context.Context, sel ast.SelectionSet, obj *types.Status) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "code":
			out.Values[i] = ec._Status_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Status_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uploadInventoryImplementors = []string{"UploadInventory"}

func (ec *executionContext) _UploadInventory(ctx context.Context, sel ast.SelectionSet, obj *types.UploadInventory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uploadInventoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UploadInventory")
		case "id":
			out.Values[i] = ec._UploadInventory_id(ctx, field, obj)
		case "success":
			out.Values[i] = ec._UploadInventory_success(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._UploadInventory_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uploadInventoryResponseImplementors = []string{"UploadInventoryResponse"}

func (ec *executionContext) _UploadInventoryResponse(ctx context.Context, sel ast.SelectionSet, obj *types.UploadInventoryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uploadInventoryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UploadInventoryResponse")
		case "data":
			out.Values[i] = ec._UploadInventoryResponse_data(ctx, field, obj)
		case "status":
			out.Values[i] = ec._UploadInventoryResponse_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDeletedMode2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedMode(ctx context.Context, v interface{}) (types.DeletedMode, error) {
	var res types.DeletedMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeletedMode2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedMode(ctx context.Context, sel ast.SelectionSet, v types.DeletedMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDeletedType2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedType(ctx context.Context, v interface{}) (types.DeletedType, error) {
	var res types.DeletedType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeletedType2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedType(ctx context.Context, sel ast.SelectionSet, v types.DeletedType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNRecoveryHardDeletedInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐRecoveryHardDeletedInput(ctx context.Context, v interface{}) (types.RecoveryHardDeletedInput, error) {
	res, err := ec.unmarshalInputRecoveryHardDeletedInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUploadInventoryInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUploadInventoryInput(ctx context.Context, v interface{}) (types.UploadInventoryInput, error) {
	res, err := ec.unmarshalInputUploadInventoryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertInventoryBranchInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryBranchInput(ctx context.Context, v interface{}) (types.UpsertInventoryBranchInput, error) {
	res, err := ec.unmarshalInputUpsertInventoryBranchInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertInventoryBrandInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryBrandInput(ctx context.Context, v interface{}) (types.UpsertInventoryBrandInput, error) {
	res, err := ec.unmarshalInputUpsertInventoryBrandInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertInventoryInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryInput(ctx context.Context, v interface{}) (types.UpsertInventoryInput, error) {
	res, err := ec.unmarshalInputUpsertInventoryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertInventoryTypeInput2marchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryTypeInput(ctx context.Context, v interface{}) (types.UpsertInventoryTypeInput, error) {
	res, err := ec.unmarshalInputUpsertInventoryTypeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalODeletedInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventory(ctx context.Context, sel ast.SelectionSet, v *types.DeletedInventory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletedInventory(ctx, sel, v)
}

func (ec *executionContext) marshalODeletedInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryResponse(ctx context.Context, sel ast.SelectionSet, v *types.DeletedInventoryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletedInventoryResponse(ctx, sel, v)
}

func (ec *executionContext) marshalODeletedInventoryType2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryType(ctx context.Context, sel ast.SelectionSet, v []*types.DeletedInventoryType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODeletedInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODeletedInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedInventoryType(ctx context.Context, sel ast.SelectionSet, v *types.DeletedInventoryType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletedInventoryType(ctx, sel, v)
}

func (ec *executionContext) unmarshalODeletedMode2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedMode(ctx context.Context, v interface{}) (*types.DeletedMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(types.DeletedMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeletedMode2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedMode(ctx context.Context, sel ast.SelectionSet, v *types.DeletedMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODeletedType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedType(ctx context.Context, v interface{}) (*types.DeletedType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(types.DeletedType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeletedType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐDeletedType(ctx context.Context, sel ast.SelectionSet, v *types.DeletedType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFavoriteStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐFavoriteStatus(ctx context.Context, v interface{}) (*types.FavoriteStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(types.FavoriteStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFavoriteStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐFavoriteStatus(ctx context.Context, sel ast.SelectionSet, v *types.FavoriteStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOInventoriesResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoriesResponse(ctx context.Context, sel ast.SelectionSet, v *types.InventoriesResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoriesResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOInventory2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventory(ctx context.Context, sel ast.SelectionSet, v []*types.Inventory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventory(ctx context.Context, sel ast.SelectionSet, v *types.Inventory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Inventory(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryBranch2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBranch(ctx context.Context, sel ast.SelectionSet, v []*types.InventoryBranch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInventoryBranch2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBranch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOInventoryBranch2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBranch(ctx context.Context, sel ast.SelectionSet, v *types.InventoryBranch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryBranch(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryBranchsDataResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBranchsDataResponse(ctx context.Context, sel ast.SelectionSet, v *types.InventoryBranchsDataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryBranchsDataResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryBrand2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrand(ctx context.Context, sel ast.SelectionSet, v []*types.InventoryBrand) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInventoryBrand2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOInventoryBrand2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrand(ctx context.Context, sel ast.SelectionSet, v *types.InventoryBrand) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryBrand(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryBrandsDataResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryBrandsDataResponse(ctx context.Context, sel ast.SelectionSet, v *types.InventoryBrandsDataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryBrandsDataResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryDataResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryDataResponse(ctx context.Context, sel ast.SelectionSet, v *types.InventoryDataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryDataResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryName2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryName(ctx context.Context, sel ast.SelectionSet, v []*types.InventoryName) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInventoryName2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryName(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOInventoryName2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryName(ctx context.Context, sel ast.SelectionSet, v *types.InventoryName) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryName(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryNameResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryNameResponse(ctx context.Context, sel ast.SelectionSet, v *types.InventoryNameResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryNameResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryType2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryType(ctx context.Context, sel ast.SelectionSet, v []*types.InventoryType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryType(ctx context.Context, sel ast.SelectionSet, v *types.InventoryType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryType(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryTypeResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryTypeResponse(ctx context.Context, sel ast.SelectionSet, v *types.InventoryTypeResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryTypeResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOInventoryTypesResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐInventoryTypesResponse(ctx context.Context, sel ast.SelectionSet, v *types.InventoryTypesResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InventoryTypesResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOMutationInventoryBranchResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryBranchResponse(ctx context.Context, sel ast.SelectionSet, v *types.MutationInventoryBranchResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MutationInventoryBranchResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOMutationInventoryBrandResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryBrandResponse(ctx context.Context, sel ast.SelectionSet, v *types.MutationInventoryBrandResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MutationInventoryBrandResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOMutationInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐMutationInventoryResponse(ctx context.Context, sel ast.SelectionSet, v *types.MutationInventoryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MutationInventoryResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOParamsInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventory(ctx context.Context, v interface{}) (*types.ParamsInventory, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputParamsInventory(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOParamsInventoryBranch2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventoryBranch(ctx context.Context, v interface{}) (*types.ParamsInventoryBranch, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputParamsInventoryBranch(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOParamsInventoryBrand2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventoryBrand(ctx context.Context, v interface{}) (*types.ParamsInventoryBrand, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputParamsInventoryBrand(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOParamsInventoryType2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐParamsInventoryType(ctx context.Context, v interface{}) (*types.ParamsInventoryType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputParamsInventoryType(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORecoveryHardDeleted2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐRecoveryHardDeleted(ctx context.Context, sel ast.SelectionSet, v *types.RecoveryHardDeleted) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RecoveryHardDeleted(ctx, sel, v)
}

func (ec *executionContext) marshalORecoveryHardDeletedResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐRecoveryHardDeletedResponse(ctx context.Context, sel ast.SelectionSet, v *types.RecoveryHardDeletedResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RecoveryHardDeletedResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOResponseId2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseID(ctx context.Context, sel ast.SelectionSet, v *types.ResponseID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResponseId(ctx, sel, v)
}

func (ec *executionContext) marshalOResponseInventories2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐResponseInventories(ctx context.Context, sel ast.SelectionSet, v *types.ResponseInventories) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResponseInventories(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSizeInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐSizeInventory(ctx context.Context, v interface{}) (*types.SizeInventory, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSizeInventory(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStatus2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐStatus(ctx context.Context, sel ast.SelectionSet, v *types.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Status(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUploadInventory2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUploadInventory(ctx context.Context, sel ast.SelectionSet, v *types.UploadInventory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UploadInventory(ctx, sel, v)
}

func (ec *executionContext) marshalOUploadInventoryResponse2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUploadInventoryResponse(ctx context.Context, sel ast.SelectionSet, v *types.UploadInventoryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UploadInventoryResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUpsertInventoryInput2ᚕᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryInput(ctx context.Context, v interface{}) ([]*types.UpsertInventoryInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*types.UpsertInventoryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOUpsertInventoryInput2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpsertInventoryInput2ᚖmarchᚑinventoryᚋcmdᚋappᚋgraphᚋtypesᚐUpsertInventoryInput(ctx context.Context, v interface{}) (*types.UpsertInventoryInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpsertInventoryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
